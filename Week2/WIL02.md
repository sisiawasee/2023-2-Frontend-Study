8장 함수
---
- 함수 정의 방법
  - 함수 선언문/리터럴(무명 함수)/Function 생성자(변수에 선언)/화살표 함수 표현식
  - 호출 코드보다 앞에 위치해야 함(함수 선언문 제외).
  - 중첩 함수(내부 함수): 외부 함수의 바깥에서는 읽거나 쓸 수 없음.
 
- 함수 호출 방법
  - 함수 호출/메소드 호출/생성자 호출(new 키워드)/call, apply 메소드(간접호출)
  - 즉시 실행 함수: 무명 함수를 정의하는 동시에 실행 -> (function(){...})(); or +function(){...}()
    - 전역 유효 범위를 오염시키지 않는 이름 공간을 생성할 때 사용 (8장 참조)

- 함수의 인수
  - 인수 생략 -> 생략 인자는 undefined가 됨.
  - 초깃값을 설정해줄 수 있음: b=b||1; (b가 없으면 1)
  - 가변 길이 인수 목록 (Arguments 객체) -> 인수 n개를 넘겨서 호출하면 인수값이 arguments에 저장
    - length와 callee를 갖고 있음 (callee: 현재 실행되고 있는 함수 참조)
    - Arguments 객체는 유사 배열 객체 (10장 참조)
    - but, 배열 객체로 변환 가능/인수 개수가 일정하지 않고, 인덱스로 값 변환시 인자의 값도 변함

- 재귀 함수
  - 하노이 탑, 팩토리얼, 퀵 정렬 등 -> 되도록 간단하게 해결할 수 있을 때만 사용하기 (원리는 똑같다.)

- 프로그램의 평가와 실행 과정 (이 부분부터 이해가 어려워 재복습 필요!)
  - 실행 가능한 코드: 전역코드/함수코드/eval 코드
  - 실행 문맥의 구성
    - 렉시컬 환경 컴포넌트: 실행을 위한 자원을 모아둔 곳 -> 유효 범위 안의 식별자와 결괏값 저장, 환경 레코드(선언적 환경 레코드(실제 함수, 변수, catch문의 식별자와 실행 결과 저장)와 객체 환경 레코드(실행 문맥 외부의 별도 저장 객체 참조에서 데이터 읽기&쓰기 ->with 등)로 구성)와 외부 렉시컬 환경 참조(중첩 함수 등)로 구성되어 있음
    - 싱글 스레드와 멀티스레드: 싱글스레드는 순차실행, 멀티스레드는 병렬실행
    - 디스 바인딩 컴포넌트: this 값은 환경에 따라 바뀜(=동적)
  - 속박 변수&닫힌 함수, 자유 변수&열린 함수: 함수의 인수와 지역 변수-> 속박 변수 (속박 변수만을 가지면 닫힌 함수), 자유 변수는 전역 실행 문맥의 환경 레코드에서 확인 가능 (스코프 체인, 외부 렉시켤 환경 체인, 유효 범위 체인에서 식별자 확인)
  - 가비지 컬렉션: 다른 객체의 프로퍼티와 변수가 참조하지 않는 객체 -> 메모리 누수 발생 가능(ex: 순환 참조)

- 클로저: 자기 자신이 정의된 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행
  - 렉시컬 환경 컴포넌트 생성 및 참조
  - 캡슐화된 객체임
  - 반복문 안에서 클로저를 만들지 않을 것 (매번 새로운 객체가 생성되거나, for문의 경우 잘못된 변수 참조 가능 -> 즉시 실행 함수에 카운터 변수를 전달하는 방식으로 해결도 가능함.)
 
- 이름 공간: 전역 유효 범위의 오염을 방지하기 위함 (-> namespace 같은 느낌)
  - 객체 자체를 이름 공간으로 활용: 객체를 지역 범위로 설정해줌. 부분 이름 공간을 만들 수도 있음.
  - 함수를 이름 공간으로 활용: 함수 내부의 지역변수로 선언
    - 모듈 패턴: 모듈 바깥의 변수와 충돌 가능 -> 즉시 실행 함수를 통해 해결 (클로저의 내부 상태로 저장)

- 객체로서의 함수
  - 함수는 Function 객체임 -> 변수/프로퍼티/배열 요소에 대입 가능, 함수의 인수/반환값으로 사용 가능, 프로퍼티/메서드 보유 가능, 무명 함수 표현 가능, 동적 생성 가능. (이러한 작업이 가능할 경우 일급 함수->JS의 함수는 일급 함수)
  - 함수의 프로퍼티: caller, length, name, prototype
  - function 생성자의 prototype 객체 상속 가능 (ex. apply, bind, call 등)
    - apply(배열 인수)/call(쉼표 구분 값)
   
- 고차 함수: 함수를 인수로 받거나 함수를 반환하는 함수: joinString, random 함수를 인수로 받는 것 등
  - 메모이제이션 기법을 적용한 함수로 가공 가능 -> memorize ... 객체 cache 안에 저장함 (재귀 함수 사용)
  - 합성 함수도 가능
  - 커링 -> 인수를 두개 이상 받는 함수를 분해하여 인수가 하나인 함수의 중첩 함수로 변환하는 작업
 
- 콜백 함수: 다른 함수에 인수로 넘겨지는 함수
  - 이벤트 처리기, 타이머 등

- 기타: 태그 함수, 화살표 함수 등
  - 태그가 지정된 템플릿 리터럴: func`${a}+${b}=${a+b}`
    - 첫 번째 인수가 문자열 요소를 담은 배열
    - HTML에서 사용할 수 없는 문자를 이스케이프 시퀀스로 바꿀 수 있음
    - 태그 함수의 첫번째 인수(callSite 객체): 동결된 객체, 캐시됨, raw 프로퍼티가 있음.
   
9장 객체
---
- 객체 생성
  - 객체 생성 방법: 리터럴, 생성자, Object.create
  - 프로토타입: 인스턴스에 아무것도 정의하지 않아도 처음부터 사용 가능 -> 인스턴스가 프로토타입 객체 상속(프로토타입 체인 메커니즘으로 구현)
  - 메소드 체인: 객체는 한 번, 메소드는 여러 개 호출
 
- 프로토타입 상속
  - 프로토타입 체인
    - 모든 객체 -> 내부 프로퍼티를 가짐. __proto__ 프로퍼티는 객체에게 상속을 해준 부모 객체를 가리킴
    - 자신이 갖고 있지 않은 프로퍼티를 상속 차례대로 거슬러 올라가며 검색 (프로토타입 체인)
  - 프로토타입의 확인: instanceof 연산자/isPrototypeOf 메소드 사용
 
- 접근자 프로퍼티
  - 프로퍼티 종류: 데이터 프로퍼티(값 저장), 접근자 프로퍼티(호출함수를 값 대신 지정
  - 접근자 프로퍼티: 객체 바깥에서 객체의 프로퍼티를 읽거나 쓸 수 있도록 함
    - read: getter/write: setter
  - 데이터 캡슐화를 위함, 즉시 실행 함수로 클로저 생성시에는 외부에서 읽고 쓸 수 없도록 숨기고 접근자 프로퍼티로만 접근 가능
 
- 프로퍼티 속성: 쓰기/열거 가능, 재정의 기능
  - 프로퍼티 디스크립터: 프로퍼티 기술자, 프로퍼티의 속성을 설정 가능
    - 데이터 프로퍼티 디스크립터: value, writable, enumerable, configurable 포함
    - 접근자 프로퍼티 디스크립터: get, set, enumerable, configurable 포함

- 프로퍼티 확인하기
  - in 연산자/hasOwnProperty 메소드/rpopertyIsEnumerable 메소드

- 프로퍼티의 열거
  - for/in 문/Object.keys 메소드/Object.getOwnPropertyNames 메소드

- 객체 잠그기
  - 확장 가능 속성: 객체에 새로운 프로퍼티 추가 가능 여부 결정
  - 확장 방지: Object.preventExtensions 메소드
  - 밀봉(추가 및 재정의 금지):  Object.seal 메소드
  - 동결(밀봉+데이터 프로퍼티 읽기 전용): Object.freeze 메소드

- Mixin : 서로 다른 객체 프로퍼티를 뒤섞음 -> 프로퍼티 복사 함수 필요 (ex. 9.3~9.4 확인)

- JSON:자바스크립트 객체를 문자열로 표현하는 데이터 포맷, 객체를 직렬화 가능
  - 타 프로그래밍 언어와의 데이터 송수신을 간단하게 만듦.
  - ex: {name: "Tom", age: 17, marriage:false, data: [2, 5, null]}; -> '{"name": "Tom", "age": 17, "marriage":false, "data": [2, 5, null]}'
  - 자바스크립트 객체를 JSON 문자열로 변환하기: JSON.stringify(value[, replacer[, space]])
  - JSON 문자열을 자바스크립트 객체로 환원하기: JSON.parse(text[,reviver])
 
10장 배열의 다양한 기능
---
- 배열 메소드: 10.1.1(p285) 참조
  - 대부분(확인한 것들)은 C++이나 python과 비슷함
- 다차원 배열: 행렬 등
- 유사 배열 객체: Array.prototype의 메소드 사용 불가능->Function.prototype.call 메소드 간접 호출로 사용 가능
- 배열의 비구조화 할당 부분 조금 더 체크할 것(Object Destructuring)

11장 버그와 오류에 대처하는 방법
---
- 버그 대처
  - 버그의 원인: 논리적 버그, 오타, 실행 환경의 변화
  - Strict 모드 사용: 버그 발생을 알 수 있도록 언어의 사양 제한 -> "use strict"; 사용
    - this의 값은 undefined, with문 사용 불가, 함수 정의문에 같은 이름의 인수가 있으면 문법 오류 발생
  - 스타일 가이드 활용...(VS code의 확장프로그램 같은 느낌인 듯함)
  - Console 디버깅, 웹 브라우저의 개발자 도구를 사용한 디버깅
  - 프로그램 테스트...> 단위 테스트/통합 테스트/시스템 테스트/운용 테스트

- 예외 처리
  - exception-throw(throw-catch/try/finally 문), null 반환
    - Error 객체: 범용적인 예외를 표현, 이외의 EvalError,TypeError,URIErro 등은 특정 예외 발생 시 표현
    - c++의 try-catch 문과 같음
  - 비동기 처리의 콜백 함수가 던진 예외의 처리: 전파되지 않음

12장 정규 표현식
---
- 정규 표현식의 기본
  - 정규 표현식: 문자열의 패턴을 표현하기 위한 도구
  - 생성: RegExp 객체로 표현-> 정규 쵸현식은 RegExp 생성자 or 정규 표현식 리터럴로 생성 가능
  - 패턴 매칭: 어떤 문자열이 정규 표현식의 문자열 패턴을 갖고 있을 때 정규 표현식과 일치한다고 표현->확인하는 작업을 패턴 매칭이라고 함
 
- 기본 정규 표현식 패턴 작성: 메타 문자를 사용한 기본 정규 표현식 only
  - 리터럴 문자: 유니코드 문자+'\로 시작하는 문자(특수문자)'
  - 문자 클래스: [...](대괄호로 묶기, 하이픈 사용으로 문자 범위 지정 가능, ^으로 부정, '.'는 줄바꿈 제외 임의의 문자, '\d, \D'는 숫자와 숫자 외의 문자, '\w, \W'는 단어문자와 단어 문자 외의 문자, '\s, \S'는 공백 문자와 공백 문자 외의 문자
  - 반복 패턴: {m,n} (최소 m번, 최대 n번 반복), 최대 한번 반복:? (={0,1}) 등
  - 그룹화와 참조: (...)로 그룹화
  - 플래그
 
- 패턴 매칭을 하는 문자열 메소드
  - 검색: search 메소드
  - 문자열 치환: replace 메소드 ($& 등)
  - 문자열 추출: match 메소드
  - 문자열 나누기: split 메소드
 
13장 웹 브라우저의 객체
---
- 클라이언트 측 자바스크립트
  - 웹 브라우저에서의 자바스크립트: 웹 페이지의 Document 제어(HTML&CSS 작업), 웹 페이지의 Window 객체 제어 및 브라우저 제어, 웹 페이지에서 발생하는 이벤트 처리, HTTP를 이용한 통신 제어
  - HTML<-JS 코드 삽입: 인라인 스크립트, 외부 파일 읽어들이기(외부스크립트), 이벤트 처리기 속성에 작성, JavaScript: URL (자바스크립트 의사 프로토콜)
 
- Location 객체
  - hash, host, hostname...등으로 URL 관리

- History 객체: 웹페이지 열람 이력 관리
  - 프로퍼티: length(현재 세션 이력 개수 읽기), scrollRestoration (이동시 자동 스크롤 기능->auto or manual) state (상태값 읽기)
  - 메소드: 표 13-7(p371) 참조

- Navigator 객체: 웹 브라우저 등의 애플리케이션 정보 관리
  - 프로퍼티: 표 13-8(p372) 참조
  - 메소드: 표 13-9(p372) 참조

- Screen 객체: 모니터 크기와 색상 등의 정보 확인
  - 프로퍼티: 표 13-10(p373) 참조

- Document 객체 (DOM 제외)
  - 프로퍼티: 표 13-11(p374) 참조
  - 메소드: 표 13-12(p374) 참조
 
- 창 제어: 각 창과 탭은 별도의 브라우징 컨텍스트 제공
  - 창 여닫기, 제어하기, 다른 창 참조하기 가능)

14장 문서 제어
---
- JS로 HTML 요소와 CSS 스타일 제어 -> Interactive 웹 페이지 구성 가능
- DOM 트리: 문서 제어 API
  - 노드: DOM 트리를 구성하는 하나의 객체
    - 문서 노드/HTML 요소 노드/텍스트 노드로 구별
  - 노드 객체의 프로퍼티 표 14-1(p381) 참조
  - HTML 요소의 트리: HTML 문서 안 요소만 관심 있을 때 유용
  - 노드 객체 가져오기: id, 요소 이름, CSS 선택자, Document 객체의 프로퍼티 사용
  - 속성 값의 읽기와 쓰기(속성 이름=속성 값, id 속성과 href 속성 설정)
 
- HTML 요소의 내용 읽고 쓰기 (6장에서 언급)
  - 노드 생성/삽입/삭제: createElement, 이 외에도 표 14-5(p401) 참조
  - HTML 요소 위치: 뷰 포트 좌표계, 문서 좌표계 등

15장 이벤트 처리
---
(책 외 공부 내용 추가 수정 필요)
- 이벤트 리스너: addEventListner 등록/removeEventListener 삭제
- 이벤트 객체
- 이벤트 전파-> 캡처링, 타깃, 버블링
